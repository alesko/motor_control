#if (UC_DEVICE == XMC4100) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX22:public output<port,pin>
{
public:
    VADC_EMUX22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX22<2,15>::VADC_EMUX22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4100) && (UC_PACKAGE == VQFN48)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4104) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX22:public output<port,pin>
{
public:
    VADC_EMUX22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX22<2,15>::VADC_EMUX22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4104) && (UC_PACKAGE == VQFN48)
template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4108) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX22:public output<port,pin>
{
public:
    VADC_EMUX22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX22<2,15>::VADC_EMUX22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4108) && (UC_PACKAGE == VQFN48)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4200) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX22:public output<port,pin>
{
public:
    VADC_EMUX22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX22<2,15>::VADC_EMUX22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4200) && (UC_PACKAGE == VQFN48)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4300) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_LED_ERR:public output<port,pin>
{
public:
    ECAT0_LED_ERR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_ERR<0,7>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_ERR<1,10>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_RUN:public output<port,pin>
{
public:
    ECAT0_LED_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_RUN<0,8>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_RUN<1,11>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_STATE_RUN:public output<port,pin>
{
public:
    ECAT0_LED_STATE_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_STATE_RUN<1,11>::ECAT0_LED_STATE_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_MCLK:public output<port,pin>
{
public:
    ECAT0_MCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MCLK<3,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_MDO:public output<port,pin>
{
public:
    ECAT0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MDO<0,12>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_P0_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P0_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_LED_LINK_ACT<1,12>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<5,2>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P0_TXD0:public output<port,pin>
{
public:
    ECAT0_P0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD0<1,6>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD1:public output<port,pin>
{
public:
    ECAT0_P0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD1<1,7>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD2:public output<port,pin>
{
public:
    ECAT0_P0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD2<1,8>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD3:public output<port,pin>
{
public:
    ECAT0_P0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD3<1,2>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P0_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TX_ENA<1,3>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P1_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_LED_LINK_ACT<0,11>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_TXD0:public output<port,pin>
{
public:
    ECAT0_P1_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD0<3,1>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD1:public output<port,pin>
{
public:
    ECAT0_P1_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD1<3,2>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD2:public output<port,pin>
{
public:
    ECAT0_P1_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD2<0,2>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_TXD3:public output<port,pin>
{
public:
    ECAT0_P1_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD3<0,3>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD3<2,15>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P1_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P1_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TX_ENA<3,0>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_PHY_CLK25:public output<port,pin>
{
public:
    ECAT0_PHY_CLK25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_CLK25<1,13>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_PHY_CLK25<4,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_PHY_RESET:public output<port,pin>
{
public:
    ECAT0_PHY_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_RESET<0,0>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_PHY_RESET<2,10>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_SYNC0:public output<port,pin>
{
public:
    ECAT0_SYNC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC0<1,14>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_SYNC0<5,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_SYNC1:public output<port,pin>
{
public:
    ECAT0_SYNC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC1<2,10>::ECAT0_SYNC1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4400) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<3,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<4,0>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<4,1>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<1,15>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4400) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<1,15>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4402) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<3,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<4,0>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<4,1>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<1,15>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4402) && (UC_PACKAGE == LQFP64)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<1,15>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT00:public output<port,pin>
{
public:
    HRPWM0_OUT00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT00<0,5>::HRPWM0_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT01:public output<port,pin>
{
public:
    HRPWM0_OUT01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT01<0,2>::HRPWM0_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT10:public output<port,pin>
{
public:
    HRPWM0_OUT10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT10<0,8>::HRPWM0_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT11:public output<port,pin>
{
public:
    HRPWM0_OUT11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT11<0,7>::HRPWM0_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT20:public output<port,pin>
{
public:
    HRPWM0_OUT20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT20<0,3>::HRPWM0_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT21:public output<port,pin>
{
public:
    HRPWM0_OUT21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT21<0,4>::HRPWM0_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT30:public output<port,pin>
{
public:
    HRPWM0_OUT30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT30<0,6>::HRPWM0_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class HRPWM0_OUT31:public output<port,pin>
{
public:
    HRPWM0_OUT31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline HRPWM0_OUT31<0,9>::HRPWM0_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4500) && (UC_PACKAGE == BGA144)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4500) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4500) && (UC_PACKAGE == LQFP144)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4502) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4504) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4504) && (UC_PACKAGE == LQFP144)
template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4700) && (UC_PACKAGE == BGA196)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<6,5>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<7,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<5,8>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<7,2>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N5_TXD<5,11>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N5_TXD<7,8>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<7,4>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<7,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<7,6>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<7,7>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<7,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT32<7,10>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT33<7,11>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CCU81_OUT11<8,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CCU81_OUT21<8,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<8,8>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<7,8>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<8,0>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<8,1>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<8,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<8,3>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A19<7,0>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A20<7,1>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A21<7,2>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A22<7,3>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT3<5,3>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U0C0_DOUT0<8,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U0C0_SCLKOUT<8,5>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<8,6>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO1<8,4>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C0_DOUT0<6,6>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<9,3>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<9,1>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<9,0>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO1<9,2>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO2<9,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO3<9,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO4<9,7>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C1_DOUT0<9,10>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO3:public output<port,pin>
{
public:
    U2C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO3<9,11>::U2C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4700) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4700) && (UC_PACKAGE == LQFP144)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<6,5>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<5,8>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N5_TXD<5,11>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT3<5,3>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C0_DOUT0<6,6>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4800) && (UC_PACKAGE == BGA196)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<6,5>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<7,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<5,8>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<7,2>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N5_TXD<5,11>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N5_TXD<7,8>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<7,4>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<7,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<7,6>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<7,7>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<7,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT32<7,10>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT33<7,11>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CCU81_OUT11<8,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CCU81_OUT21<8,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<8,9>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<7,8>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<8,0>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<8,1>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<8,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<8,3>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A19<7,0>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A20<7,1>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A21<7,2>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}
template <>
inline EBU_A22<7,3>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_LED_ERR:public output<port,pin>
{
public:
    ECAT0_LED_ERR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_ERR<0,7>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_ERR<1,10>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_LED_ERR<9,5>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_RUN:public output<port,pin>
{
public:
    ECAT0_LED_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_RUN<0,8>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_RUN<1,11>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_LED_RUN<9,4>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_STATE_RUN:public output<port,pin>
{
public:
    ECAT0_LED_STATE_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_STATE_RUN<1,11>::ECAT0_LED_STATE_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_LED_STATE_RUN<9,4>::ECAT0_LED_STATE_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_MCLK:public output<port,pin>
{
public:
    ECAT0_MCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MCLK<3,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_MCLK<4,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_MCLK<9,6>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_MDO:public output<port,pin>
{
public:
    ECAT0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MDO<0,12>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ECAT0_MDO<4,2>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ECAT0_MDO<9,7>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_P0_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P0_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_LED_LINK_ACT<1,12>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<5,2>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<6,3>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<9,8>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD0:public output<port,pin>
{
public:
    ECAT0_P0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD0<1,6>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD0<6,2>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_TXD0<7,0>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD1:public output<port,pin>
{
public:
    ECAT0_P0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD1<1,7>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD1<6,4>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_TXD1<7,1>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD2:public output<port,pin>
{
public:
    ECAT0_P0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD2<1,8>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD2<6,5>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_TXD2<7,2>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD3:public output<port,pin>
{
public:
    ECAT0_P0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD3<1,2>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD3<6,6>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_TXD3<7,3>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P0_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TX_ENA<1,3>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TX_ENA<6,1>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_TX_ENA<7,8>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P1_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_LED_LINK_ACT<0,11>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_LED_LINK_ACT<3,12>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_LED_LINK_ACT<9,9>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_TXD0:public output<port,pin>
{
public:
    ECAT0_P1_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD0<2,11>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD0<3,1>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_P1_TXD0<8,0>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_TXD1:public output<port,pin>
{
public:
    ECAT0_P1_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD1<2,12>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD1<3,2>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_P1_TXD1<8,1>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_TXD2:public output<port,pin>
{
public:
    ECAT0_P1_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD2<0,2>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD2<2,13>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD2<8,2>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_TXD3:public output<port,pin>
{
public:
    ECAT0_P1_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD3<0,3>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD3<2,15>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD3<8,3>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P1_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TX_ENA<3,0>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P1_TX_ENA<5,8>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TX_ENA<8,8>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_PHY_CLK25:public output<port,pin>
{
public:
    ECAT0_PHY_CLK25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_CLK25<1,13>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_PHY_CLK25<4,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_PHY_CLK25<6,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_PHY_CLK25<9,3>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_PHY_RESET:public output<port,pin>
{
public:
    ECAT0_PHY_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_RESET<0,0>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_PHY_RESET<2,10>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_PHY_RESET<9,2>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_SYNC0:public output<port,pin>
{
public:
    ECAT0_SYNC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC0<1,14>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_SYNC0<3,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_SYNC0<5,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_SYNC0<9,0>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_SYNC1:public output<port,pin>
{
public:
    ECAT0_SYNC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC1<2,10>::ECAT0_SYNC1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_SYNC1<9,1>::ECAT0_SYNC1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT3<5,3>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U0C0_DOUT0<8,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U0C0_SCLKOUT<8,5>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<8,6>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO1<8,4>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C0_DOUT0<6,6>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<9,3>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<9,1>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<9,0>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO1<9,2>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO2<9,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO3<9,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO4<9,7>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C1_DOUT0<9,10>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO3:public output<port,pin>
{
public:
    U2C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO3<9,11>::U2C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4800) && (UC_PACKAGE == LQFP100)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class ECAT0_LED_ERR:public output<port,pin>
{
public:
    ECAT0_LED_ERR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_ERR<0,7>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_ERR<1,10>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_RUN:public output<port,pin>
{
public:
    ECAT0_LED_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_RUN<0,8>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_RUN<1,11>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_STATE_RUN:public output<port,pin>
{
public:
    ECAT0_LED_STATE_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_STATE_RUN<1,11>::ECAT0_LED_STATE_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_MCLK:public output<port,pin>
{
public:
    ECAT0_MCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MCLK<3,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_MDO:public output<port,pin>
{
public:
    ECAT0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MDO<0,12>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_P0_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P0_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_LED_LINK_ACT<1,12>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<5,2>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P0_TXD0:public output<port,pin>
{
public:
    ECAT0_P0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD0<1,6>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD1:public output<port,pin>
{
public:
    ECAT0_P0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD1<1,7>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD2:public output<port,pin>
{
public:
    ECAT0_P0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD2<1,8>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TXD3:public output<port,pin>
{
public:
    ECAT0_P0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD3<1,2>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P0_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P0_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TX_ENA<1,3>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P1_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_LED_LINK_ACT<0,11>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_TXD0:public output<port,pin>
{
public:
    ECAT0_P1_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD0<3,1>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD1:public output<port,pin>
{
public:
    ECAT0_P1_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD1<3,2>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD2:public output<port,pin>
{
public:
    ECAT0_P1_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD2<0,2>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_TXD3:public output<port,pin>
{
public:
    ECAT0_P1_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD3<0,3>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD3<2,15>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P1_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P1_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TX_ENA<3,0>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_PHY_CLK25:public output<port,pin>
{
public:
    ECAT0_PHY_CLK25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_CLK25<1,13>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_PHY_CLK25<4,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_PHY_RESET:public output<port,pin>
{
public:
    ECAT0_PHY_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_RESET<0,0>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_PHY_RESET<2,10>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_SYNC0:public output<port,pin>
{
public:
    ECAT0_SYNC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC0<1,14>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_SYNC0<5,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_SYNC1:public output<port,pin>
{
public:
    ECAT0_SYNC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC1<2,10>::ECAT0_SYNC1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
#if (UC_DEVICE == XMC4800) && (UC_PACKAGE == LQFP144)
template <int port, int pin>
class CAN_N0_TXD:public output<port,pin>
{
public:
    CAN_N0_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N0_TXD<0,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<1,4>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<2,0>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N0_TXD<3,10>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N0_TXD<3,2>::CAN_N0_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N1_TXD:public output<port,pin>
{
public:
    CAN_N1_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N1_TXD<1,12>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<1,5>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N1_TXD<2,7>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N1_TXD<3,9>::CAN_N1_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N2_TXD:public output<port,pin>
{
public:
    CAN_N2_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N2_TXD<1,9>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<3,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline CAN_N2_TXD<4,7>::CAN_N2_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CAN_N3_TXD:public output<port,pin>
{
public:
    CAN_N3_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N3_TXD<4,0>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N3_TXD<6,5>::CAN_N3_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class CAN_N4_TXD:public output<port,pin>
{
public:
    CAN_N4_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N4_TXD<2,14>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline CAN_N4_TXD<5,8>::CAN_N4_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CAN_N5_TXD:public output<port,pin>
{
public:
    CAN_N5_TXD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CAN_N5_TXD<2,1>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline CAN_N5_TXD<5,11>::CAN_N5_TXD(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU40_OUT0:public output<port,pin>
{
public:
    CCU40_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT0<0,15>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT0<1,3>::CCU40_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT1:public output<port,pin>
{
public:
    CCU40_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT1<0,14>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT1<1,2>::CCU40_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT2:public output<port,pin>
{
public:
    CCU40_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT2<0,13>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT2<1,1>::CCU40_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU40_OUT3:public output<port,pin>
{
public:
    CCU40_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU40_OUT3<0,12>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU40_OUT3<1,0>::CCU40_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT0:public output<port,pin>
{
public:
    CCU41_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT0<2,5>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT0<3,10>::CCU41_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT1:public output<port,pin>
{
public:
    CCU41_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT1<2,4>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT1<3,9>::CCU41_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT2:public output<port,pin>
{
public:
    CCU41_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT2<2,3>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT2<3,8>::CCU41_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU41_OUT3:public output<port,pin>
{
public:
    CCU41_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU41_OUT3<2,2>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU41_OUT3<3,7>::CCU41_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT0:public output<port,pin>
{
public:
    CCU42_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT0<3,0>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT0<3,6>::CCU42_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT1:public output<port,pin>
{
public:
    CCU42_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT1<3,13>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT1<3,5>::CCU42_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT2:public output<port,pin>
{
public:
    CCU42_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT2<3,12>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT2<3,4>::CCU42_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU42_OUT3:public output<port,pin>
{
public:
    CCU42_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU42_OUT3<3,11>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU42_OUT3<3,3>::CCU42_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT0:public output<port,pin>
{
public:
    CCU43_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT0<4,6>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT0<6,5>::CCU43_OUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT1:public output<port,pin>
{
public:
    CCU43_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT1<4,5>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT1<6,4>::CCU43_OUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT2:public output<port,pin>
{
public:
    CCU43_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT2<4,4>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT2<6,3>::CCU43_OUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU43_OUT3:public output<port,pin>
{
public:
    CCU43_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline CCU43_OUT3<4,3>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU43_OUT3<6,2>::CCU43_OUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT00:public output<port,pin>
{
public:
    CCU80_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT00<0,5>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT00<5,11>::CCU80_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT01:public output<port,pin>
{
public:
    CCU80_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU80_OUT01<0,2>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT01<5,8>::CCU80_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT02:public output<port,pin>
{
public:
    CCU80_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT02<0,10>::CCU80_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT03:public output<port,pin>
{
public:
    CCU80_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC80;}
    operator uint8_t() { return 0; }
    enum { module=0, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU80_OUT03<2,7>::CCU80_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT10:public output<port,pin>
{
public:
    CCU80_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT10<0,4>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT10<5,10>::CCU80_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT11:public output<port,pin>
{
public:
    CCU80_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU80_OUT11<0,1>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT11<2,15>::CCU80_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT12:public output<port,pin>
{
public:
    CCU80_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT12<0,9>::CCU80_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT13:public output<port,pin>
{
public:
    CCU80_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC81;}
    operator uint8_t() { return 1; }
    enum { module=0, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU80_OUT13<2,6>::CCU80_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT20:public output<port,pin>
{
public:
    CCU80_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT20<0,3>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT20<5,9>::CCU80_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT21:public output<port,pin>
{
public:
    CCU80_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU80_OUT21<0,0>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT21<2,14>::CCU80_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT22:public output<port,pin>
{
public:
    CCU80_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT22<2,11>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU80_OUT22<2,9>::CCU80_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT23:public output<port,pin>
{
public:
    CCU80_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC82;}
    operator uint8_t() { return 2; }
    enum { module=0, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU80_OUT23<1,5>::CCU80_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT30:public output<port,pin>
{
public:
    CCU80_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT30<0,6>::CCU80_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT31:public output<port,pin>
{
public:
    CCU80_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU80_OUT31<0,11>::CCU80_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT32:public output<port,pin>
{
public:
    CCU80_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT32<2,8>::CCU80_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU80_OUT33:public output<port,pin>
{
public:
    CCU80_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU80; }
    operator XMC_CCU8_SLICE_t*() { return CCU80_CC83;}
    operator uint8_t() { return 3; }
    enum { module=0, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU80_OUT33<1,4>::CCU80_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT00:public output<port,pin>
{
public:
    CCU81_OUT00(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT00<1,15>::CCU81_OUT00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT01:public output<port,pin>
{
public:
    CCU81_OUT01(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR1S=i; }
};
template <>
inline CCU81_OUT01<1,12>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT01<2,2>::CCU81_OUT01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT02:public output<port,pin>
{
public:
    CCU81_OUT02(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT02<5,7>::CCU81_OUT02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT03:public output<port,pin>
{
public:
    CCU81_OUT03(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC80;}
    operator uint8_t() { return 0; }
    enum { module=1, slice=0};
    void operator=(uint32_t i) { CCU80_CC80->CR2S=i; }
};
template <>
inline CCU81_OUT03<5,6>::CCU81_OUT03(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT10:public output<port,pin>
{
public:
    CCU81_OUT10(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT10<1,14>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT10<1,5>::CCU81_OUT10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT11:public output<port,pin>
{
public:
    CCU81_OUT11(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR1S=i; }
};
template <>
inline CCU81_OUT11<1,11>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT11<2,1>::CCU81_OUT11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT12:public output<port,pin>
{
public:
    CCU81_OUT12(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT12<5,5>::CCU81_OUT12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT13:public output<port,pin>
{
public:
    CCU81_OUT13(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC81;}
    operator uint8_t() { return 1; }
    enum { module=1, slice=1};
    void operator=(uint32_t i) { CCU80_CC81->CR2S=i; }
};
template <>
inline CCU81_OUT13<5,4>::CCU81_OUT13(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT20:public output<port,pin>
{
public:
    CCU81_OUT20(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT20<1,13>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT20<1,4>::CCU81_OUT20(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class CCU81_OUT21:public output<port,pin>
{
public:
    CCU81_OUT21(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR1S=i; }
};
template <>
inline CCU81_OUT21<1,10>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT21<2,0>::CCU81_OUT21(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class CCU81_OUT22:public output<port,pin>
{
public:
    CCU81_OUT22(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT22<5,3>::CCU81_OUT22(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT23:public output<port,pin>
{
public:
    CCU81_OUT23(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC82;}
    operator uint8_t() { return 2; }
    enum { module=1, slice=2};
    void operator=(uint32_t i) { CCU80_CC82->CR2S=i; }
};
template <>
inline CCU81_OUT23<5,2>::CCU81_OUT23(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT30:public output<port,pin>
{
public:
    CCU81_OUT30(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT30<6,1>::CCU81_OUT30(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT31:public output<port,pin>
{
public:
    CCU81_OUT31(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR1S=i; }
};
template <>
inline CCU81_OUT31<6,0>::CCU81_OUT31(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT32:public output<port,pin>
{
public:
    CCU81_OUT32(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT32<5,1>::CCU81_OUT32(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class CCU81_OUT33:public output<port,pin>
{
public:
    CCU81_OUT33(void) { static_assert(port<0,"Illegal pin");}
    operator XMC_CCU8_MODULE_t*() { return CCU81; }
    operator XMC_CCU8_SLICE_t*() { return CCU81_CC83;}
    operator uint8_t() { return 3; }
    enum { module=1, slice=3};
    void operator=(uint32_t i) { CCU80_CC83->CR2S=i; }
};
template <>
inline CCU81_OUT33<2,12>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline CCU81_OUT33<5,0>::CCU81_OUT33(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DB_ETM_TRACECLK:public output<port,pin>
{
public:
    DB_ETM_TRACECLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACECLK<2,14>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACECLK<6,0>::DB_ETM_TRACECLK(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA0:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA0<2,13>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA0<6,6>::DB_ETM_TRACEDATA0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA1:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA1<2,12>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA1<6,5>::DB_ETM_TRACEDATA1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA2:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA2<2,11>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA2<6,2>::DB_ETM_TRACEDATA2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_ETM_TRACEDATA3:public output<port,pin>
{
public:
    DB_ETM_TRACEDATA3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_ETM_TRACEDATA3<2,10>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline DB_ETM_TRACEDATA3<6,1>::DB_ETM_TRACEDATA3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DB_TDO_TRACESWO:public output<port,pin>
{
public:
    DB_TDO_TRACESWO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DB_TDO_TRACESWO<2,1>::DB_TDO_TRACESWO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class DSD_CGPWMN:public output<port,pin>
{
public:
    DSD_CGPWMN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMN<1,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMN<2,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMN<5,0>::DSD_CGPWMN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_CGPWMP:public output<port,pin>
{
public:
    DSD_CGPWMP(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_CGPWMP<1,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline DSD_CGPWMP<2,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_CGPWMP<5,1>::DSD_CGPWMP(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class DSD_MCLK0:public output<port,pin>
{
public:
    DSD_MCLK0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK0<1,9>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK0<4,1>::DSD_MCLK0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK1:public output<port,pin>
{
public:
    DSD_MCLK1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK1<1,8>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline DSD_MCLK1<4,0>::DSD_MCLK1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK2:public output<port,pin>
{
public:
    DSD_MCLK2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK2<1,15>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline DSD_MCLK2<1,7>::DSD_MCLK2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class DSD_MCLK3:public output<port,pin>
{
public:
    DSD_MCLK3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline DSD_MCLK3<3,4>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline DSD_MCLK3<6,6>::DSD_MCLK3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class EBU_A16:public output<port,pin>
{
public:
    EBU_A16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A16<6,0>::EBU_A16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A17:public output<port,pin>
{
public:
    EBU_A17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A17<6,1>::EBU_A17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A18:public output<port,pin>
{
public:
    EBU_A18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A18<6,2>::EBU_A18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A19:public output<port,pin>
{
public:
    EBU_A19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A19<6,4>::EBU_A19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A20:public output<port,pin>
{
public:
    EBU_A20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A20<5,3>::EBU_A20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A21:public output<port,pin>
{
public:
    EBU_A21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A21<5,4>::EBU_A21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A22:public output<port,pin>
{
public:
    EBU_A22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A22<5,5>::EBU_A22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_A23:public output<port,pin>
{
public:
    EBU_A23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_A23<5,6>::EBU_A23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD0:public output<port,pin>
{
public:
    EBU_AD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD0<0,2>::EBU_AD0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD1:public output<port,pin>
{
public:
    EBU_AD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD1<0,3>::EBU_AD1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD10:public output<port,pin>
{
public:
    EBU_AD10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD10<1,6>::EBU_AD10(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD11:public output<port,pin>
{
public:
    EBU_AD11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD11<1,7>::EBU_AD11(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD12:public output<port,pin>
{
public:
    EBU_AD12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD12<1,8>::EBU_AD12(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD13:public output<port,pin>
{
public:
    EBU_AD13(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD13<1,9>::EBU_AD13(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD14:public output<port,pin>
{
public:
    EBU_AD14(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD14<1,2>::EBU_AD14(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD15:public output<port,pin>
{
public:
    EBU_AD15(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD15<1,3>::EBU_AD15(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD16:public output<port,pin>
{
public:
    EBU_AD16(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD16<1,12>::EBU_AD16(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD17:public output<port,pin>
{
public:
    EBU_AD17(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD17<1,13>::EBU_AD17(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD18:public output<port,pin>
{
public:
    EBU_AD18(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD18<1,14>::EBU_AD18(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD19:public output<port,pin>
{
public:
    EBU_AD19(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD19<1,15>::EBU_AD19(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD2:public output<port,pin>
{
public:
    EBU_AD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD2<0,4>::EBU_AD2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD20:public output<port,pin>
{
public:
    EBU_AD20(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD20<2,0>::EBU_AD20(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD21:public output<port,pin>
{
public:
    EBU_AD21(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD21<2,1>::EBU_AD21(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD22:public output<port,pin>
{
public:
    EBU_AD22(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD22<2,2>::EBU_AD22(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD23:public output<port,pin>
{
public:
    EBU_AD23(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD23<2,3>::EBU_AD23(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD24:public output<port,pin>
{
public:
    EBU_AD24(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD24<2,4>::EBU_AD24(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD25:public output<port,pin>
{
public:
    EBU_AD25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD25<2,5>::EBU_AD25(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD26:public output<port,pin>
{
public:
    EBU_AD26(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD26<2,8>::EBU_AD26(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD27:public output<port,pin>
{
public:
    EBU_AD27(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD27<2,9>::EBU_AD27(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD28:public output<port,pin>
{
public:
    EBU_AD28(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD28<2,10>::EBU_AD28(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD29:public output<port,pin>
{
public:
    EBU_AD29(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD29<2,11>::EBU_AD29(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD3:public output<port,pin>
{
public:
    EBU_AD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD3<0,5>::EBU_AD3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD30:public output<port,pin>
{
public:
    EBU_AD30(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD30<2,12>::EBU_AD30(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD31:public output<port,pin>
{
public:
    EBU_AD31(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD31<2,13>::EBU_AD31(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD4:public output<port,pin>
{
public:
    EBU_AD4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD4<3,5>::EBU_AD4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD5:public output<port,pin>
{
public:
    EBU_AD5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD5<3,6>::EBU_AD5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD6:public output<port,pin>
{
public:
    EBU_AD6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD6<0,7>::EBU_AD6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD7:public output<port,pin>
{
public:
    EBU_AD7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD7<0,8>::EBU_AD7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD8:public output<port,pin>
{
public:
    EBU_AD8(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD8<4,0>::EBU_AD8(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_AD9:public output<port,pin>
{
public:
    EBU_AD9(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_AD9<4,1>::EBU_AD9(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_ADV:public output<port,pin>
{
public:
    EBU_ADV(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_ADV<0,6>::EBU_ADV(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC0:public output<port,pin>
{
public:
    EBU_BC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC0<2,14>::EBU_BC0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC1:public output<port,pin>
{
public:
    EBU_BC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC1<2,15>::EBU_BC1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC2:public output<port,pin>
{
public:
    EBU_BC2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC2<6,5>::EBU_BC2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BC3:public output<port,pin>
{
public:
    EBU_BC3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BC3<6,6>::EBU_BC3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_BFCLKO:public output<port,pin>
{
public:
    EBU_BFCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BFCLKO<5,6>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_BFCLKO<5,9>::EBU_BFCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_BREQ:public output<port,pin>
{
public:
    EBU_BREQ(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_BREQ<0,11>::EBU_BREQ(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CAS:public output<port,pin>
{
public:
    EBU_CAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CAS<5,5>::EBU_CAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CKE:public output<port,pin>
{
public:
    EBU_CKE(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CKE<5,3>::EBU_CKE(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_CS0:public output<port,pin>
{
public:
    EBU_CS0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS0<3,2>::EBU_CS0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS1:public output<port,pin>
{
public:
    EBU_CS1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS1<0,9>::EBU_CS1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS2:public output<port,pin>
{
public:
    EBU_CS2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS2<5,8>::EBU_CS2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_CS3:public output<port,pin>
{
public:
    EBU_CS3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_CS3<5,9>::EBU_CS3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_HLDA_OUT:public output<port,pin>
{
public:
    EBU_HLDA_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_HLDA_OUT<0,12>::EBU_HLDA_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RAS:public output<port,pin>
{
public:
    EBU_RAS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RAS<5,4>::EBU_RAS(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class EBU_RD:public output<port,pin>
{
public:
    EBU_RD(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD<3,0>::EBU_RD(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_RD_NWR:public output<port,pin>
{
public:
    EBU_RD_NWR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_RD_NWR<3,1>::EBU_RD_NWR(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL2);
}

template <int port, int pin>
class EBU_SDCLKO:public output<port,pin>
{
public:
    EBU_SDCLKO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline EBU_SDCLKO<5,8>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline EBU_SDCLKO<6,4>::EBU_SDCLKO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_LED_ERR:public output<port,pin>
{
public:
    ECAT0_LED_ERR(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_ERR<0,7>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_ERR<1,10>::ECAT0_LED_ERR(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_RUN:public output<port,pin>
{
public:
    ECAT0_LED_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_RUN<0,8>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}
template <>
inline ECAT0_LED_RUN<1,11>::ECAT0_LED_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_LED_STATE_RUN:public output<port,pin>
{
public:
    ECAT0_LED_STATE_RUN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_LED_STATE_RUN<1,11>::ECAT0_LED_STATE_RUN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_MCLK:public output<port,pin>
{
public:
    ECAT0_MCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MCLK<3,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_MCLK<4,3>::ECAT0_MCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_MDO:public output<port,pin>
{
public:
    ECAT0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_MDO<0,12>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ECAT0_MDO<4,2>::ECAT0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ECAT0_P0_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P0_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_LED_LINK_ACT<1,12>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<5,2>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P0_LED_LINK_ACT<6,3>::ECAT0_P0_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD0:public output<port,pin>
{
public:
    ECAT0_P0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD0<1,6>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD0<6,2>::ECAT0_P0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD1:public output<port,pin>
{
public:
    ECAT0_P0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD1<1,7>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD1<6,4>::ECAT0_P0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD2:public output<port,pin>
{
public:
    ECAT0_P0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD2<1,8>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD2<6,5>::ECAT0_P0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TXD3:public output<port,pin>
{
public:
    ECAT0_P0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TXD3<1,2>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TXD3<6,6>::ECAT0_P0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P0_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P0_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P0_TX_ENA<1,3>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P0_TX_ENA<6,1>::ECAT0_P0_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_P1_LED_LINK_ACT:public output<port,pin>
{
public:
    ECAT0_P1_LED_LINK_ACT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_LED_LINK_ACT<0,11>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_LED_LINK_ACT<3,12>::ECAT0_P1_LED_LINK_ACT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_P1_TXD0:public output<port,pin>
{
public:
    ECAT0_P1_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD0<2,11>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD0<3,1>::ECAT0_P1_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD1:public output<port,pin>
{
public:
    ECAT0_P1_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD1<2,12>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_P1_TXD1<3,2>::ECAT0_P1_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_P1_TXD2:public output<port,pin>
{
public:
    ECAT0_P1_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD2<0,2>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD2<2,13>::ECAT0_P1_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P1_TXD3:public output<port,pin>
{
public:
    ECAT0_P1_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TXD3<0,3>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_P1_TXD3<2,15>::ECAT0_P1_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class ECAT0_P1_TX_ENA:public output<port,pin>
{
public:
    ECAT0_P1_TX_ENA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_P1_TX_ENA<3,0>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_P1_TX_ENA<5,8>::ECAT0_P1_TX_ENA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_PHY_CLK25:public output<port,pin>
{
public:
    ECAT0_PHY_CLK25(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_CLK25<1,13>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_PHY_CLK25<4,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ECAT0_PHY_CLK25<6,0>::ECAT0_PHY_CLK25(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ECAT0_PHY_RESET:public output<port,pin>
{
public:
    ECAT0_PHY_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_PHY_RESET<0,0>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_PHY_RESET<2,10>::ECAT0_PHY_RESET(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT3));
}

template <int port, int pin>
class ECAT0_SYNC0:public output<port,pin>
{
public:
    ECAT0_SYNC0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC0<1,14>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ECAT0_SYNC0<3,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ECAT0_SYNC0<5,7>::ECAT0_SYNC0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ECAT0_SYNC1:public output<port,pin>
{
public:
    ECAT0_SYNC1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ECAT0_SYNC1<2,10>::ECAT0_SYNC1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT0:public output<port,pin>
{
public:
    ERU1_PDOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT0<1,3>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT0<2,10>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT0<5,0>::ERU1_PDOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT1:public output<port,pin>
{
public:
    ERU1_PDOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT1<1,2>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT1<2,8>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT1<5,1>::ERU1_PDOUT1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT2:public output<port,pin>
{
public:
    ERU1_PDOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT2<1,1>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT2<2,9>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT2<5,2>::ERU1_PDOUT2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ERU1_PDOUT3:public output<port,pin>
{
public:
    ERU1_PDOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ERU1_PDOUT3<1,0>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ERU1_PDOUT3<2,6>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline ERU1_PDOUT3<5,3>::ERU1_PDOUT3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class ETH0_MDC:public output<port,pin>
{
public:
    ETH0_MDC(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDC<0,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<1,10>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_MDC<2,7>::ETH0_MDC(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_MDO:public output<port,pin>
{
public:
    ETH0_MDO(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_MDO<0,9>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<1,11>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline ETH0_MDO<2,0>::ETH0_MDO(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class ETH0_TXD0:public output<port,pin>
{
public:
    ETH0_TXD0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD0<0,5>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<1,13>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD0<2,12>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD0<2,8>::ETH0_TXD0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD1:public output<port,pin>
{
public:
    ETH0_TXD1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD1<0,6>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<1,14>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD1<2,13>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline ETH0_TXD1<2,9>::ETH0_TXD1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD2:public output<port,pin>
{
public:
    ETH0_TXD2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD2<2,12>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD2<6,0>::ETH0_TXD2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXD3:public output<port,pin>
{
public:
    ETH0_TXD3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXD3<2,13>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXD3<6,1>::ETH0_TXD3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TXER:public output<port,pin>
{
public:
    ETH0_TXER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TXER<2,11>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TXER<6,2>::ETH0_TXER(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class ETH0_TX_EN:public output<port,pin>
{
public:
    ETH0_TX_EN(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline ETH0_TX_EN<0,4>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<1,12>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<2,5>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline ETH0_TX_EN<5,9>::ETH0_TX_EN(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL0:public output<port,pin>
{
public:
    LEDTS0_COL0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL0<0,9>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL0<2,1>::LEDTS0_COL0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL1:public output<port,pin>
{
public:
    LEDTS0_COL1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL1<0,10>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL1<2,0>::LEDTS0_COL1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL2:public output<port,pin>
{
public:
    LEDTS0_COL2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL2<0,0>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL2<2,7>::LEDTS0_COL2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COL3:public output<port,pin>
{
public:
    LEDTS0_COL3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COL3<0,1>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COL3<2,6>::LEDTS0_COL3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_COLA:public output<port,pin>
{
public:
    LEDTS0_COLA(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_COLA<3,2>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_COLA<5,7>::LEDTS0_COLA(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE0:public output<port,pin>
{
public:
    LEDTS0_LINE0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE0<2,2>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE0<3,7>::LEDTS0_LINE0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE1:public output<port,pin>
{
public:
    LEDTS0_LINE1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE1<2,3>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE1<3,8>::LEDTS0_LINE1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE2:public output<port,pin>
{
public:
    LEDTS0_LINE2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE2<2,4>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE2<3,9>::LEDTS0_LINE2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE3:public output<port,pin>
{
public:
    LEDTS0_LINE3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE3<2,5>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE3<3,10>::LEDTS0_LINE3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE4:public output<port,pin>
{
public:
    LEDTS0_LINE4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE4<2,8>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE4<3,11>::LEDTS0_LINE4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE5:public output<port,pin>
{
public:
    LEDTS0_LINE5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE5<2,9>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE5<3,12>::LEDTS0_LINE5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE6:public output<port,pin>
{
public:
    LEDTS0_LINE6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE6<2,15>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline LEDTS0_LINE6<3,13>::LEDTS0_LINE6(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_LINE7:public output<port,pin>
{
public:
    LEDTS0_LINE7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_LINE7<5,10>::LEDTS0_LINE7(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class LEDTS0_TSIN0:public output<port,pin>
{
public:
    LEDTS0_TSIN0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN0<2,2>::LEDTS0_TSIN0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN1:public output<port,pin>
{
public:
    LEDTS0_TSIN1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN1<2,3>::LEDTS0_TSIN1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN2:public output<port,pin>
{
public:
    LEDTS0_TSIN2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN2<2,4>::LEDTS0_TSIN2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN3:public output<port,pin>
{
public:
    LEDTS0_TSIN3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN3<2,5>::LEDTS0_TSIN3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN4:public output<port,pin>
{
public:
    LEDTS0_TSIN4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN4<2,8>::LEDTS0_TSIN4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN5:public output<port,pin>
{
public:
    LEDTS0_TSIN5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN5<2,9>::LEDTS0_TSIN5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN6:public output<port,pin>
{
public:
    LEDTS0_TSIN6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN6<2,15>::LEDTS0_TSIN6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class LEDTS0_TSIN7:public output<port,pin>
{
public:
    LEDTS0_TSIN7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline LEDTS0_TSIN7<5,10>::LEDTS0_TSIN7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SCU_EXTCLK:public output<port,pin>
{
public:
    SCU_EXTCLK(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SCU_EXTCLK<0,8>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline SCU_EXTCLK<1,15>::SCU_EXTCLK(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class SDMMC_BUS_POWER:public output<port,pin>
{
public:
    SDMMC_BUS_POWER(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_BUS_POWER<3,4>::SDMMC_BUS_POWER(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CLK_OUT:public output<port,pin>
{
public:
    SDMMC_CLK_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CLK_OUT<3,6>::SDMMC_CLK_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_CMD_OUT:public output<port,pin>
{
public:
    SDMMC_CMD_OUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_CMD_OUT<3,5>::SDMMC_CMD_OUT(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT0:public output<port,pin>
{
public:
    SDMMC_DATA_OUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT0<4,0>::SDMMC_DATA_OUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT1:public output<port,pin>
{
public:
    SDMMC_DATA_OUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT1<1,6>::SDMMC_DATA_OUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT2:public output<port,pin>
{
public:
    SDMMC_DATA_OUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT2<1,7>::SDMMC_DATA_OUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT3:public output<port,pin>
{
public:
    SDMMC_DATA_OUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT3<4,1>::SDMMC_DATA_OUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT4:public output<port,pin>
{
public:
    SDMMC_DATA_OUT4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT4<1,8>::SDMMC_DATA_OUT4(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT5:public output<port,pin>
{
public:
    SDMMC_DATA_OUT5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT5<1,9>::SDMMC_DATA_OUT5(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT6:public output<port,pin>
{
public:
    SDMMC_DATA_OUT6(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT6<1,12>::SDMMC_DATA_OUT6(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_DATA_OUT7:public output<port,pin>
{
public:
    SDMMC_DATA_OUT7(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_DATA_OUT7<1,13>::SDMMC_DATA_OUT7(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_LED:public output<port,pin>
{
public:
    SDMMC_LED(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_LED<3,3>::SDMMC_LED(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class SDMMC_RESET:public output<port,pin>
{
public:
    SDMMC_RESET(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline SDMMC_RESET<0,11>::SDMMC_RESET(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT0:public output<port,pin>
{
public:
    U0C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT0<1,5>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C0_DOUT0<1,7>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_DOUT0<5,1>::U0C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_DOUT1:public output<port,pin>
{
public:
    U0C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT1<1,4>::U0C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT2:public output<port,pin>
{
public:
    U0C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT2<1,3>::U0C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_DOUT3:public output<port,pin>
{
public:
    U0C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_DOUT3<1,2>::U0C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C0_MCLKOUT:public output<port,pin>
{
public:
    U0C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_MCLKOUT<1,3>::U0C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SCLKOUT:public output<port,pin>
{
public:
    U0C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SCLKOUT<0,8>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,1>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,10>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,6>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SCLKOUT<1,9>::U0C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U0C0_SELO0:public output<port,pin>
{
public:
    U0C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO0<0,7>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,0>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C0_SELO0<1,11>::U0C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO1:public output<port,pin>
{
public:
    U0C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO1<1,8>::U0C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO2:public output<port,pin>
{
public:
    U0C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO2<4,6>::U0C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO3:public output<port,pin>
{
public:
    U0C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO3<4,5>::U0C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO4:public output<port,pin>
{
public:
    U0C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO4<4,4>::U0C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C0_SELO5:public output<port,pin>
{
public:
    U0C0_SELO5(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C0_SELO5<4,3>::U0C0_SELO5(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT0:public output<port,pin>
{
public:
    U0C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT0<2,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_DOUT0<3,13>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U0C1_DOUT0<3,5>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_DOUT0<6,4>::U0C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_DOUT1:public output<port,pin>
{
public:
    U0C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT1<3,12>::U0C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT2:public output<port,pin>
{
public:
    U0C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT2<3,11>::U0C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_DOUT3:public output<port,pin>
{
public:
    U0C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_DOUT3<3,10>::U0C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U0C1_MCLKOUT:public output<port,pin>
{
public:
    U0C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_MCLKOUT<6,5>::U0C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SCLKOUT:public output<port,pin>
{
public:
    U0C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SCLKOUT<2,4>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,0>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SCLKOUT<3,6>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SCLKOUT<6,2>::U0C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO0:public output<port,pin>
{
public:
    U0C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO0<2,3>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<3,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO0<4,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U0C1_SELO0<6,1>::U0C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO1:public output<port,pin>
{
public:
    U0C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO1<3,12>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO1<6,0>::U0C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO2:public output<port,pin>
{
public:
    U0C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO2<1,14>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO2<3,11>::U0C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U0C1_SELO3:public output<port,pin>
{
public:
    U0C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U0C1_SELO3<1,13>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U0C1_SELO3<3,8>::U0C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT0:public output<port,pin>
{
public:
    U1C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT0<0,5>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C0_DOUT0<1,15>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_DOUT0<2,14>::U1C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_DOUT1:public output<port,pin>
{
public:
    U1C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT1<0,4>::U1C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT2:public output<port,pin>
{
public:
    U1C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT2<0,3>::U1C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_DOUT3:public output<port,pin>
{
public:
    U1C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_DOUT3<0,2>::U1C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C0_MCLKOUT:public output<port,pin>
{
public:
    U1C0_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_MCLKOUT<5,10>::U1C0_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SCLKOUT:public output<port,pin>
{
public:
    U1C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SCLKOUT<0,11>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SCLKOUT<4,0>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C0_SCLKOUT<5,8>::U1C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO0:public output<port,pin>
{
public:
    U1C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO0<0,6>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO0<5,9>::U1C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO1:public output<port,pin>
{
public:
    U1C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO1<0,14>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C0_SELO1<5,11>::U1C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO2:public output<port,pin>
{
public:
    U1C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO2<0,15>::U1C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C0_SELO3:public output<port,pin>
{
public:
    U1C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C0_SELO3<3,14>::U1C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT0:public output<port,pin>
{
public:
    U1C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT0<0,1>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_DOUT0<1,9>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_DOUT0<3,15>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U1C1_DOUT0<4,2>::U1C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_DOUT1:public output<port,pin>
{
public:
    U1C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT1<3,14>::U1C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT2:public output<port,pin>
{
public:
    U1C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT2<0,15>::U1C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_DOUT3:public output<port,pin>
{
public:
    U1C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_DOUT3<0,14>::U1C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U1C1_MCLKOUT:public output<port,pin>
{
public:
    U1C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_MCLKOUT<4,1>::U1C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SCLKOUT:public output<port,pin>
{
public:
    U1C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SCLKOUT<0,10>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<0,13>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SCLKOUT<1,8>::U1C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U1C1_SELO0:public output<port,pin>
{
public:
    U1C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO0<0,12>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO0<0,9>::U1C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO1:public output<port,pin>
{
public:
    U1C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO1<0,2>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}
template <>
inline U1C1_SELO1<3,3>::U1C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO2:public output<port,pin>
{
public:
    U1C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO2<1,7>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}
template <>
inline U1C1_SELO2<3,4>::U1C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO3:public output<port,pin>
{
public:
    U1C1_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO3<3,5>::U1C1_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U1C1_SELO4:public output<port,pin>
{
public:
    U1C1_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U1C1_SELO4<3,6>::U1C1_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT2));
}

template <int port, int pin>
class U2C0_DOUT0:public output<port,pin>
{
public:
    U2C0_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT0<3,8>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_DOUT0<5,0>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}
template <>
inline U2C0_DOUT0<6,6>::U2C0_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_DOUT1:public output<port,pin>
{
public:
    U2C0_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT1<5,1>::U2C0_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT2:public output<port,pin>
{
public:
    U2C0_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT2<5,7>::U2C0_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_DOUT3:public output<port,pin>
{
public:
    U2C0_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_DOUT3<2,6>::U2C0_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C0_SCLKOUT:public output<port,pin>
{
public:
    U2C0_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SCLKOUT<3,9>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SCLKOUT<5,2>::U2C0_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO0:public output<port,pin>
{
public:
    U2C0_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO0<3,10>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C0_SELO0<5,3>::U2C0_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO1:public output<port,pin>
{
public:
    U2C0_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO1<5,4>::U2C0_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO2:public output<port,pin>
{
public:
    U2C0_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO2<5,5>::U2C0_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO3:public output<port,pin>
{
public:
    U2C0_SELO3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO3<5,6>::U2C0_SELO3(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C0_SELO4:public output<port,pin>
{
public:
    U2C0_SELO4(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C0_SELO4<2,6>::U2C0_SELO4(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_DOUT0:public output<port,pin>
{
public:
    U2C1_DOUT0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT0<3,11>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<3,5>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_DOUT0<4,7>::U2C1_DOUT0(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT1:public output<port,pin>
{
public:
    U2C1_DOUT1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT1<4,6>::U2C1_DOUT1(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT2:public output<port,pin>
{
public:
    U2C1_DOUT2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT2<4,5>::U2C1_DOUT2(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_DOUT3:public output<port,pin>
{
public:
    U2C1_DOUT3(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_DOUT3<4,4>::U2C1_DOUT3(void)
{
    set(XMC_GPIO_HWCTRL_PERIPHERAL1);
}

template <int port, int pin>
class U2C1_MCLKOUT:public output<port,pin>
{
public:
    U2C1_MCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_MCLKOUT<3,4>::U2C1_MCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SCLKOUT:public output<port,pin>
{
public:
    U2C1_SCLKOUT(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SCLKOUT<3,13>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<3,6>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SCLKOUT<4,2>::U2C1_SCLKOUT(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT4));
}

template <int port, int pin>
class U2C1_SELO0:public output<port,pin>
{
public:
    U2C1_SELO0(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO0<3,0>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline U2C1_SELO0<4,1>::U2C1_SELO0(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO1:public output<port,pin>
{
public:
    U2C1_SELO1(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO1<4,2>::U2C1_SELO1(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class U2C1_SELO2:public output<port,pin>
{
public:
    U2C1_SELO2(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline U2C1_SELO2<4,3>::U2C1_SELO2(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class USB_DRIVEVBUS:public output<port,pin>
{
public:
    USB_DRIVEVBUS(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline USB_DRIVEVBUS<0,1>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline USB_DRIVEVBUS<3,2>::USB_DRIVEVBUS(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX00:public output<port,pin>
{
public:
    VADC_EMUX00(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX00<2,2>::VADC_EMUX00(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX01:public output<port,pin>
{
public:
    VADC_EMUX01(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX01<2,3>::VADC_EMUX01(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX02:public output<port,pin>
{
public:
    VADC_EMUX02(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX02<2,4>::VADC_EMUX02(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX10:public output<port,pin>
{
public:
    VADC_EMUX10(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX10<2,10>::VADC_EMUX10(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX11:public output<port,pin>
{
public:
    VADC_EMUX11(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX11<2,14>::VADC_EMUX11(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class VADC_EMUX12:public output<port,pin>
{
public:
    VADC_EMUX12(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline VADC_EMUX12<2,15>::VADC_EMUX12(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}

template <int port, int pin>
class WDT_REQUEST:public output<port,pin>
{
public:
    WDT_REQUEST(void) { static_assert(port<0,"Illegal pin");}
};
template <>
inline WDT_REQUEST<0,7>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
template <>
inline WDT_REQUEST<1,4>::WDT_REQUEST(void)
{
    set(XMC_GPIO_MODE_t(XMC_GPIO_MODE_OUTPUT_PUSH_PULL | XMC_GPIO_MODE_OUTPUT_ALT1));
}
#endif
